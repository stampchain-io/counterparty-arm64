AWSTemplateFormatVersion: '2010-09-09'
Description: 'Counterparty ARM64 on AWS Graviton with ST1 volume'

# Define mappings for AMI IDs
Mappings:
  # Ubuntu 24.04 LTS (Noble Numbat) ARM64 AMIs - updated 2025-04-03
  Ubuntu2404:
    us-east-1:
      ARM64AMI: ami-0e7cbbc0b03465aaf # Ubuntu 24.04 ARM64 - 2025-04-02
    us-east-2:
      ARM64AMI: ami-0e7cbbc0b03465aaf # Ubuntu 24.04 ARM64 - fallback to us-east-1
    us-west-1:
      ARM64AMI: ami-0e7cbbc0b03465aaf # Ubuntu 24.04 ARM64 - fallback to us-east-1
    us-west-2: 
      ARM64AMI: ami-0e7cbbc0b03465aaf # Ubuntu 24.04 ARM64 - fallback to us-east-1
    eu-west-1:
      ARM64AMI: ami-0e7cbbc0b03465aaf # Ubuntu 24.04 ARM64 - fallback to us-east-1
    ap-northeast-1:
      ARM64AMI: ami-0e7cbbc0b03465aaf # Ubuntu 24.04 ARM64 - fallback to us-east-1
    ap-southeast-1:
      ARM64AMI: ami-0e7cbbc0b03465aaf # Ubuntu 24.04 ARM64 - fallback to us-east-1
    ap-southeast-2:
      ARM64AMI: ami-0e7cbbc0b03465aaf # Ubuntu 24.04 ARM64 - fallback to us-east-1
      
  # Ubuntu 22.04 LTS (Jammy Jellyfish) ARM64 AMIs - updated 2025-04-03
  Ubuntu2204:
    us-east-1:
      ARM64AMI: ami-0836cb0ffc615b773 # Ubuntu 22.04 ARM64 - 2025-04-02
    us-east-2:
      ARM64AMI: ami-0836cb0ffc615b773 # Ubuntu 22.04 ARM64 - fallback to us-east-1
    us-west-1:
      ARM64AMI: ami-0836cb0ffc615b773 # Ubuntu 22.04 ARM64 - fallback to us-east-1
    us-west-2: 
      ARM64AMI: ami-0836cb0ffc615b773 # Ubuntu 22.04 ARM64 - fallback to us-east-1
    eu-west-1:
      ARM64AMI: ami-0836cb0ffc615b773 # Ubuntu 22.04 ARM64 - fallback to us-east-1
    ap-northeast-1:
      ARM64AMI: ami-0836cb0ffc615b773 # Ubuntu 22.04 ARM64 - fallback to us-east-1
    ap-southeast-1:
      ARM64AMI: ami-0836cb0ffc615b773 # Ubuntu 22.04 ARM64 - fallback to us-east-1
    ap-southeast-2:
      ARM64AMI: ami-0836cb0ffc615b773 # Ubuntu 22.04 ARM64 - fallback to us-east-1

# Define conditions
Conditions:
  CreateNewKey: !Equals [!Ref CreateNewKeyPair, "true"]
  UseExistingSG: !Equals [!Ref UseExistingSecurityGroup, "true"]
  CreateNewSG: !Not [!Condition UseExistingSG]
  UseUbuntu2404: !Equals [!Ref UbuntuVersion, "24.04"]
  UseUbuntu2204: !Equals [!Ref UbuntuVersion, "22.04"]
  PublicRpcEnabled: !Equals [!Ref PublicRpcAccess, "true"]
  
  # Network profile conditions
  UseMainnetProfile: !Equals [!Ref NetworkProfile, "mainnet"]
  UseTestnet3Profile: !Equals [!Ref NetworkProfile, "testnet3"]
  UseTestnet4Profile: !Equals [!Ref NetworkProfile, "testnet4"]
  UseRegtestProfile: !Equals [!Ref NetworkProfile, "regtest"]

Metadata:
  AWS::CloudFormation::Interface:
    ParameterGroups:
      - Label:
          default: "Instance Configuration"
        Parameters:
          - InstanceType
          - KeyName
          - CreateNewKeyPair
          - NewKeyPairName
          - RootVolumeSize
          - DataVolumeSize
      - Label:
          default: "Network Configuration"
        Parameters:
          - VpcId
          - SubnetId
          - YourIp
          - UseExistingSecurityGroup
          - ExistingSecurityGroupId
      - Label:
          default: "Counterparty Configuration"
        Parameters:
          - BitcoinVersion
          - CounterpartyBranch
          - CounterpartyTag
          - NetworkProfile
          - UbuntuVersion
    
    ParameterLabels:
      KeyName:
        default: "Key Pair"
      CreateNewKeyPair:
        default: "Create New Key Pair?"
      NewKeyPairName:
        default: "New Key Pair Name"
      UseExistingSecurityGroup:
        default: "Use Existing Security Group?"
      ExistingSecurityGroupId:
        default: "Existing Security Group ID"
      UbuntuVersion:
        default: "Ubuntu Version"
      NetworkProfile:
        default: "Network Profile (mainnet/testnet/regtest)"

Parameters:
  KeyName:
    Description: Name of an existing EC2 KeyPair to enable SSH access to the instance
    Type: AWS::EC2::KeyPair::KeyName
    ConstraintDescription: Must be the name of an existing EC2 KeyPair.

  CreateNewKeyPair:
    Description: Create a new key pair for this instance? (Not yet implemented, available in AWS Console)
    Type: String
    Default: "false"
    AllowedValues:
      - "true"
      - "false"

  NewKeyPairName:
    Description: Name for the new key pair (only used if creating a new key pair)
    Type: String
    Default: "counterparty-keypair"
    MinLength: 1
    MaxLength: 255
    ConstraintDescription: Must be a valid key pair name.
  
  VpcId:
    Description: VPC ID where the instance will be launched
    Type: AWS::EC2::VPC::Id
  
  SubnetId:
    Description: Subnet ID where the instance will be launched
    Type: AWS::EC2::Subnet::Id
    
  UseExistingSecurityGroup:
    Description: Use an existing security group instead of creating a new one?
    Type: String
    Default: "false"
    AllowedValues:
      - "true"
      - "false"
  
  ExistingSecurityGroupId:
    Description: ID of existing security group (only used if UseExistingSecurityGroup is true)
    Type: String
    Default: ""
    
  PublicRpcAccess:
    Description: Allow public access to RPC port 4000? (Warning - Security Risk)
    Type: String
    Default: "false"
    AllowedValues:
      - "true"
      - "false"
      
  
  InstanceType:
    Description: EC2 instance type (Graviton-based)
    Type: String
    Default: m7g.xlarge
    AllowedValues:
      - m7g.large
      - m7g.xlarge
      - m7g.2xlarge
      - c7g.xlarge
      - c7g.2xlarge
    ConstraintDescription: Must be a valid Graviton-based instance type.
  
  RootVolumeSize:
    Description: Size of the root volume in GB
    Type: Number
    Default: 100
    MinValue: 8
    MaxValue: 500
  
  DataVolumeSize:
    Description: Size of the data volume in GB
    Type: Number
    Default: 1000
    MinValue: 500
    MaxValue: 16000
  
  YourIp:
    Description: Your IP address to allow SSH access (e.g., 123.123.123.123/32)
    Type: String
    AllowedPattern: (\d{1,3})\.(\d{1,3})\.(\d{1,3})\.(\d{1,3})/(\d{1,2})
    ConstraintDescription: Must be a valid CIDR range of the form x.x.x.x/x.
  
  BitcoinVersion:
    Description: Bitcoin Core version to use
    Type: String
    Default: "26.0"
  
  CounterpartyBranch:
    Description: Counterparty branch to use
    Type: String
    Default: "master"
  
  CounterpartyTag:
    Description: Counterparty tag to use (optional)
    Type: String
    Default: ""
    
  UbuntuVersion:
    Description: Ubuntu version to use
    Type: String
    Default: "24.04"
    AllowedValues:
      - "24.04"
      - "22.04"
      
  GitHubToken:
    Description: GitHub personal access token for private repository access (optional)
    Type: String
    Default: ""
    NoEcho: true
      
  NetworkProfile:
    Description: Bitcoin/Counterparty network profile to use
    Type: String
    Default: "mainnet"
    AllowedValues:
      - "mainnet"
      - "testnet3"
      - "testnet4"
      - "regtest"

Resources:
  # Security Group for the Counterparty node (created if UseExistingSecurityGroup is false)
  CounterpartySecurityGroup:
    Type: AWS::EC2::SecurityGroup
    Condition: CreateNewSG
    Properties:
      GroupDescription: Security group for Counterparty node
      VpcId: !Ref VpcId
      SecurityGroupIngress:
        - IpProtocol: tcp
          FromPort: 22
          ToPort: 22
          CidrIp: !Ref YourIp
        # Bitcoin P2P ports - conditionally exposed based on network profile
        # Mainnet
        - !If
          - UseMainnetProfile
          - IpProtocol: tcp
            FromPort: 8333
            ToPort: 8333
            CidrIp: 0.0.0.0/0
          - !Ref AWS::NoValue
        # Testnet3
        - !If
          - UseTestnet3Profile
          - IpProtocol: tcp
            FromPort: 18333
            ToPort: 18333
            CidrIp: 0.0.0.0/0
          - !Ref AWS::NoValue
        # Testnet4
        - !If
          - UseTestnet4Profile
          - IpProtocol: tcp
            FromPort: 49333
            ToPort: 49333
            CidrIp: 0.0.0.0/0
          - !Ref AWS::NoValue
        # Regtest
        - !If
          - UseRegtestProfile
          - IpProtocol: tcp
            FromPort: 29333
            ToPort: 29333
            CidrIp: 0.0.0.0/0
          - !Ref AWS::NoValue
            
        # Counterparty API websocket port
        - IpProtocol: tcp
          FromPort: 4001
          ToPort: 4001
          CidrIp: 0.0.0.0/0
        # Bitcoin RPC ports - conditionally exposed based on network profile
        # Mainnet RPC
        - !If
          - UseMainnetProfile
          - IpProtocol: tcp
            FromPort: 8332
            ToPort: 8332
            CidrIp: !Ref YourIp
          - !Ref AWS::NoValue
        # Testnet3 RPC
        - !If
          - UseTestnet3Profile
          - IpProtocol: tcp
            FromPort: 18332
            ToPort: 18332
            CidrIp: !Ref YourIp
          - !Ref AWS::NoValue
        # Testnet4 RPC
        - !If
          - UseTestnet4Profile
          - IpProtocol: tcp
            FromPort: 48332
            ToPort: 48332
            CidrIp: !Ref YourIp
          - !Ref AWS::NoValue
        # Regtest RPC
        - !If
          - UseRegtestProfile
          - IpProtocol: tcp
            FromPort: 18443
            ToPort: 18443
            CidrIp: !Ref YourIp
          - !Ref AWS::NoValue
        # Counterparty API ports - conditionally exposed based on network profile
        # Mainnet API
        - !If
          - UseMainnetProfile
          - IpProtocol: tcp
            FromPort: 4000
            ToPort: 4000
            CidrIp: !Ref YourIp
          - !Ref AWS::NoValue
        # Testnet3 API
        - !If
          - UseTestnet3Profile
          - IpProtocol: tcp
            FromPort: 14000
            ToPort: 14000
            CidrIp: !Ref YourIp
          - !Ref AWS::NoValue
        # Testnet4 API
        - !If
          - UseTestnet4Profile
          - IpProtocol: tcp
            FromPort: 44000
            ToPort: 44000
            CidrIp: !Ref YourIp
          - !Ref AWS::NoValue
        # Regtest API
        - !If
          - UseRegtestProfile
          - IpProtocol: tcp
            FromPort: 24000
            ToPort: 24000
            CidrIp: !Ref YourIp
          - !Ref AWS::NoValue
          
        # Rule 2: Allow VPC internal access using RFC1918 private ranges
        - IpProtocol: tcp
          FromPort: 4000
          ToPort: 4000
          CidrIp: 10.0.0.0/8  # AWS typically uses this range
        - IpProtocol: tcp
          FromPort: 4000
          ToPort: 4000
          CidrIp: 172.16.0.0/12
        - IpProtocol: tcp
          FromPort: 4000
          ToPort: 4000
          CidrIp: 192.168.0.0/16
        
        # Rule 3: Public access to Counterparty API (if enabled)
        - !If
          - PublicRpcEnabled
          - IpProtocol: tcp
            FromPort: 4000
            ToPort: 4000
            CidrIp: 0.0.0.0/0
          - !Ref AWS::NoValue
      Tags:
        - Key: Name
          Value: !Sub "${AWS::StackName}-sg"

  # ST1 volume for blockchain data
  DataVolume:
    Type: AWS::EC2::Volume
    Properties:
      AvailabilityZone: !GetAtt CounterpartyInstance.AvailabilityZone
      Size: !Ref DataVolumeSize
      VolumeType: st1
      Tags:
        - Key: Name
          Value: counterparty-data-st1

  # Volume attachment
  DataVolumeAttachment:
    Type: AWS::EC2::VolumeAttachment
    Properties:
      InstanceId: !Ref CounterpartyInstance
      VolumeId: !Ref DataVolume
      Device: /dev/sdf

  # IAM Role for the instance
  CounterpartyInstanceRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: ec2.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/AmazonSSMManagedInstanceCore
      Policies:
        - PolicyName: CounterpartySnapshotPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - ec2:CreateSnapshot
                  - ec2:DeleteSnapshot
                  - ec2:DescribeSnapshots
                  - ec2:DescribeVolumes
                  - ec2:ModifySnapshotAttribute
                  - ec2:ResetSnapshotAttribute
                Resource: '*'

  # Instance profile
  CounterpartyInstanceProfile:
    Type: AWS::IAM::InstanceProfile
    Properties:
      Roles:
        - !Ref CounterpartyInstanceRole

  # Optional: Create a new key pair if requested
  # Note: CloudFormation doesn't currently support returning the private key content,
  # so we recommend creating the key pair in the console if needed
  CounterpartyKeyPair:
    Type: AWS::EC2::KeyPair
    Condition: CreateNewKey
    Properties:
      KeyName: !Ref NewKeyPairName
      Tags:
        - Key: Name
          Value: !Sub "${AWS::StackName}-keypair"

  # EC2 Instance
  CounterpartyInstance:
    Type: AWS::EC2::Instance
    Properties:
      InstanceType: !Ref InstanceType
      ImageId: !If
        - UseUbuntu2404
        - !FindInMap [Ubuntu2404, !Ref "AWS::Region", ARM64AMI]
        - !FindInMap [Ubuntu2204, !Ref "AWS::Region", ARM64AMI]
      KeyName: !If [CreateNewKey, !Ref CounterpartyKeyPair, !Ref KeyName]
      IamInstanceProfile: !Ref CounterpartyInstanceProfile
      SecurityGroupIds:
        - !If [UseExistingSG, !Ref ExistingSecurityGroupId, !Ref CounterpartySecurityGroup]
      SubnetId: !Ref SubnetId
      BlockDeviceMappings:
        - DeviceName: /dev/sda1
          Ebs:
            VolumeSize: !Ref RootVolumeSize
            VolumeType: gp3
            DeleteOnTermination: true
      Tags:
        - Key: Name
          Value: counterparty-arm64
      UserData:
        Fn::Base64: !Sub |
          #!/bin/bash
          # Update system
          apt-get update && apt-get upgrade -y
          
          # Install basic dependencies first - we need xfsprogs for volume formatting
          apt-get install -y apt-transport-https ca-certificates curl software-properties-common git jq htop iotop xfsprogs bc
          
          # Fix for aws-cli in Ubuntu 24.04
          # First check if AWS CLI is already installed
          if ! command -v aws &> /dev/null; then
            if [ "$(lsb_release -cs)" = "noble" ]; then
              # Use alternative method for Ubuntu 24.04
              curl "https://awscli.amazonaws.com/awscli-exe-linux-aarch64.zip" -o "awscliv2.zip"
              apt-get install -y unzip
              unzip -q awscliv2.zip
              ./aws/install
              rm -rf aws awscliv2.zip
            else
              # Try standard method for older Ubuntu versions
              apt-get install -y awscli || echo "Warning: Could not install awscli package"
            fi
          fi
          
          # Add Docker repository - with improved error handling
          mkdir -p /etc/apt/keyrings
          curl -fsSL https://download.docker.com/linux/ubuntu/gpg -o docker.gpg
          if [ -f docker.gpg ]; then
            gpg --dearmor -o /etc/apt/keyrings/docker.gpg docker.gpg
            echo "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable" | tee /etc/apt/sources.list.d/docker.list > /dev/null
            apt-get update
            
            # Install Docker
            apt-get install -y docker-ce docker-ce-cli containerd.io docker-compose-plugin
          else
            echo "Failed to download Docker GPG key, using alternative method"
            # Alternative Docker installation using snap as fallback
            apt-get install -y snapd
            snap install docker
          fi
          
          # Add ubuntu user to docker group
          usermod -aG docker ubuntu
          
          # Mount the ST1 volume
          mkdir -p /bitcoin-data
          
          # Find the correct device for the attached volume (NVMe naming can vary)
          DATA_DEVICE=""
          for dev in /dev/nvme*n1; do
            if [ -e "$dev" ] && ! grep -q "$dev" /etc/fstab && [ "$dev" != "/dev/nvme0n1" ]; then
              DATA_DEVICE="$dev"
              echo "Found data device: $DATA_DEVICE"
              break
            fi
          done
          
          # If NVMe device wasn't found, try traditional naming
          if [ -z "$DATA_DEVICE" ] && [ -e "/dev/xvdf" ]; then
            DATA_DEVICE="/dev/xvdf"
            echo "Found data device: $DATA_DEVICE"
          fi
          
          if [ -z "$DATA_DEVICE" ]; then
            echo "Error: Could not find data volume device"
            # Use a fallback directory if volume can't be found
            mkdir -p /bitcoin-data-local
            ln -sf /bitcoin-data-local /bitcoin-data
          else
            # Format the volume if needed
            if ! blkid "$DATA_DEVICE"; then
              echo "Formatting $DATA_DEVICE with XFS filesystem"
              mkfs.xfs -f "$DATA_DEVICE"
            fi
            
            # Mount the volume
            echo "Mounting $DATA_DEVICE to /bitcoin-data"
            mount "$DATA_DEVICE" /bitcoin-data || {
              echo "Mount failed, attempting to force format and mount"
              mkfs.xfs -f "$DATA_DEVICE"
              mount "$DATA_DEVICE" /bitcoin-data
            }
            
            # Add to fstab for persistence
            if ! grep -q "$DATA_DEVICE" /etc/fstab; then
              echo "$DATA_DEVICE /bitcoin-data xfs defaults,nofail 0 2" >> /etc/fstab
            fi
          fi
          
          # Set permissions and create necessary directories
          mkdir -p /bitcoin-data/docker
          mkdir -p /bitcoin-data/counterparty-docker-data
          mkdir -p /bitcoin-data/repo
          chown -R ubuntu:ubuntu /bitcoin-data
          chmod -R 755 /bitcoin-data
          
          # Configure Docker to use the ST1 volume
          mkdir -p /etc/docker
          cat > /etc/docker/daemon.json << 'EOF'
          {
            "data-root": "/bitcoin-data/docker",
            "storage-driver": "overlay2",
            "log-driver": "json-file",
            "log-opts": {
              "max-size": "100m",
              "max-file": "3"
            }
          }
          EOF
          
          # Ensure Docker can access the directory
          chmod 711 /bitcoin-data/docker
          
          # Restart Docker service
          systemctl restart docker
          systemctl enable docker
          
          # Create symlink for docker-compose command for compatibility
          if [ -f "/usr/libexec/docker/cli-plugins/docker-compose" ] && [ ! -f "/usr/bin/docker-compose" ]; then
            ln -s /usr/libexec/docker/cli-plugins/docker-compose /usr/bin/docker-compose
            chmod +x /usr/bin/docker-compose
          fi
          
          # Clone counterparty-arm64 repository with retry logic
          cd /home/ubuntu
          REPO_URL="https://github.com/stampchain-io/counterparty-arm64.git"
          # Optional GitHub token parameter for private repository access
          GITHUB_TOKEN="${GitHubToken}"
          MAX_RETRIES=3
          
          for i in $(seq 1 $MAX_RETRIES); do
            echo "Cloning repository (attempt $i of $MAX_RETRIES)..."
            
            if [ -n "$GITHUB_TOKEN" ]; then
              # Use token for private repository
              echo "Using GitHub token for private repository access"
              REPO_WITH_TOKEN="https://${GITHUB_TOKEN}@github.com/stampchain-io/counterparty-arm64.git"
              git clone $REPO_WITH_TOKEN && break
            else
              # Try public access
              git clone $REPO_URL && break
            fi
            
            if [ $i -eq $MAX_RETRIES ]; then
              echo "Failed to clone repository after $MAX_RETRIES attempts"
              echo "If this is a private repository, please provide a GitHubToken parameter"
              exit 1
            fi
            
            echo "Clone failed. Retrying in 5 seconds..."
            sleep 5
          done
          
          # Clone Counterparty Core as well
          echo "Cloning Counterparty Core repository..."
          mkdir -p /bitcoin-data/repo
          chown -R ubuntu:ubuntu /bitcoin-data/repo
          cd /bitcoin-data/repo
          
          # Clone Counterparty Core - this is a public repo but could be changed
          COUNTERPARTY_REPO_URL="https://github.com/CounterpartyXCP/counterparty-core.git"
          
          if [ -n "$GITHUB_TOKEN" ]; then
            # Use token for private repository - just in case it becomes private
            COUNTERPARTY_REPO_WITH_TOKEN="https://${GITHUB_TOKEN}@github.com/CounterpartyXCP/counterparty-core.git"
            sudo -u ubuntu git clone $COUNTERPARTY_REPO_WITH_TOKEN
          else
            # Use public URL
            sudo -u ubuntu git clone $COUNTERPARTY_REPO_URL
          fi
          
          chown -R ubuntu:ubuntu counterparty-arm64
          
          # Copy common.sh to home directory for use by check-sync-status.sh
          cp /home/ubuntu/counterparty-arm64/scripts/common.sh /home/ubuntu/
          chmod +x /home/ubuntu/common.sh
          
          # Copy all Docker files to counterparty-node directory
          mkdir -p /home/ubuntu/counterparty-node
          cp /home/ubuntu/counterparty-arm64/docker/bitcoin-entrypoint.sh /home/ubuntu/counterparty-node/
          cp /home/ubuntu/counterparty-arm64/docker/Dockerfile.bitcoind /home/ubuntu/counterparty-node/
          cp /home/ubuntu/counterparty-arm64/docker/docker-compose.yml /home/ubuntu/counterparty-node/
          cp /home/ubuntu/counterparty-arm64/docker/docker-compose.build.yml /home/ubuntu/counterparty-node/
          chmod +x /home/ubuntu/counterparty-node/bitcoin-entrypoint.sh
          chown -R ubuntu:ubuntu /home/ubuntu/counterparty-node
          
          # Make sure all Bitcoin-data directories have correct permissions
          echo "Ensuring proper directory permissions..."
          chown -R ubuntu:ubuntu /bitcoin-data
          chmod -R 755 /bitcoin-data
          sudo -u ubuntu mkdir -p /bitcoin-data/repo/counterparty-core
          
          # Run setup script - retry logic in case of network issues
          echo "Running setup script..."
          su - ubuntu -c "cd counterparty-arm64 && chmod +x scripts/setup.sh && scripts/setup.sh --bitcoin-version '${BitcoinVersion}' --counterparty-branch '${CounterpartyBranch}' --data-dir '/bitcoin-data' --platform 'aws'" || {
            echo "Setup script failed on first attempt. Waiting 30 seconds and retrying..."
            sleep 30
            # Reset permissions and try again
            chown -R ubuntu:ubuntu /bitcoin-data
            chmod -R 755 /bitcoin-data
            su - ubuntu -c "cd counterparty-arm64 && scripts/setup.sh --bitcoin-version '${BitcoinVersion}' --counterparty-branch '${CounterpartyBranch}' --data-dir '/bitcoin-data' --platform 'aws'"
          }
          
          # Verify that the check-sync-status.sh script was copied correctly
          if [ ! -f /home/ubuntu/check-sync-status.sh ]; then
            echo "check-sync-status.sh was not copied by setup script, copying manually..."
            cp /home/ubuntu/counterparty-arm64/aws/scripts/check-sync-status.sh /home/ubuntu/
            chmod +x /home/ubuntu/check-sync-status.sh
          fi
          
          # Fix the check-sync-status.sh script to use the local common.sh
          sed -i 's|^SCRIPT_DIR=.*|source "/home/ubuntu/common.sh"|' /home/ubuntu/check-sync-status.sh
          sed -i '/^REPO_DIR=.*/d' /home/ubuntu/check-sync-status.sh
          sed -i '/^source "\$REPO_DIR\/scripts\/common.sh"/d' /home/ubuntu/check-sync-status.sh || true
          
          # Update docker-compose.yml to use locally built images instead of pulling from Docker Hub
          echo "Updating docker-compose.yml to use locally built images..."
          su - ubuntu -c "sed -i 's/image: bitcoind:arm64-local/image: counterparty-node_bitcoind:latest/g' ~/counterparty-node/docker-compose.yml"
          su - ubuntu -c "sed -i 's|image: counterparty/counterparty:local|image: counterparty-node_counterparty-core:latest|g' ~/counterparty-node/docker-compose.yml"
          
          # Also update the testnet4 and regtest profiles if they exist
          su - ubuntu -c "sed -i 's/image: bitcoind:arm64-local/image: counterparty-node_bitcoind:latest/g' ~/counterparty-node/docker-compose.yml"
          su - ubuntu -c "sed -i 's|image: counterparty/counterparty:local|image: counterparty-node_counterparty-core:latest|g' ~/counterparty-node/docker-compose.yml"
          
          # Build both Docker images first, then start the services
          echo "Building Docker images for ${NetworkProfile} profile..."
          
          # Export the necessary environment variables for the build
          # Create config directory if it doesn't exist
          mkdir -p /home/ubuntu/.counterparty-arm64
          
          # Create a config.env file for Docker Compose
          cat > /home/ubuntu/.counterparty-arm64/config.env << EOF
# Counterparty ARM64 Configuration
# Generated on $(date)
COUNTERPARTY_DOCKER_DATA=/bitcoin-data
COUNTERPARTY_REPO=/bitcoin-data/repo/counterparty-core
BITCOIN_VERSION=${BITCOIN_VERSION}
COUNTERPARTY_BRANCH=${COUNTERPARTY_BRANCH}
COUNTERPARTY_TAG=${COUNTERPARTY_TAG}
NETWORK_PROFILE=${NetworkProfile}
EOF
          chown -R ubuntu:ubuntu /home/ubuntu/.counterparty-arm64
          
          # Now use the environment variables for building
          su - ubuntu -c "export COUNTERPARTY_DOCKER_DATA=/bitcoin-data && export COUNTERPARTY_REPO=/bitcoin-data/repo/counterparty-core && cd ~/counterparty-node && docker compose -f docker-compose.build.yml build"
          
          # Start both Bitcoin and Counterparty with the selected network profile
          echo "Starting Bitcoin service with ${NetworkProfile} profile..."
          su - ubuntu -c "cd ~/counterparty-node && docker compose --profile ${NetworkProfile} up -d bitcoind" || echo "Failed to start Bitcoin service, check logs for details"
          
          # Copy the check-and-start-counterparty.sh script to monitor Bitcoin sync and start Counterparty
          cp /home/ubuntu/counterparty-arm64/check-and-start-counterparty.sh /home/ubuntu/
          chmod +x /home/ubuntu/check-and-start-counterparty.sh
          
          # Add to crontab to check every 5 minutes if bitcoin is synced enough to start counterparty
          (crontab -l 2>/dev/null; echo "*/5 * * * * /home/ubuntu/check-and-start-counterparty.sh >> /home/ubuntu/counterparty-startup.log 2>&1") | crontab -
          
          # Add check-sync-status.sh to cron for hourly checks
          (crontab -l 2>/dev/null; echo "0 * * * * /home/ubuntu/check-sync-status.sh > /home/ubuntu/sync-status.log 2>&1") | crontab -
          
          echo "Deployment completed. Bitcoin node is now starting. Counterparty service will be started once bootstrapping is complete."
          echo "Check status with: ~/check-sync-status.sh"

Outputs:
  InstanceId:
    Description: EC2 Instance ID
    Value: !Ref CounterpartyInstance
  
  PublicIp:
    Description: Public IP address of the instance
    Value: !GetAtt CounterpartyInstance.PublicIp
  
  PublicDns:
    Description: Public DNS name of the instance
    Value: !GetAtt CounterpartyInstance.PublicDnsName
  
  DataVolumeId:
    Description: ID of the ST1 data volume
    Value: !Ref DataVolume
    
  SSHCommand:
    Description: Command to SSH into the instance
    Value: !Sub "ssh ubuntu@${CounterpartyInstance.PublicDnsName}"
    
  KeyPairInfo:
    Description: Information about the key pair used
    Value: !If 
      - CreateNewKey
      - !Sub "New key pair '${NewKeyPairName}' was created. Download the private key from the EC2 Console."
      - !Sub "Using existing key pair '${KeyName}'."
      
  SecurityGroupInfo:
    Description: Information about the security group used
    Value: !If
      - UseExistingSG
      - !Sub "Using existing security group '${ExistingSecurityGroupId}'"
      - !If
        - CreateNewSG
        - !Sub "New security group '${CounterpartySecurityGroup}' was created."
        - "Security group information not available."
        
  UbuntuInfo:
    Description: Information about the Ubuntu version used
    Value: !If
      - UseUbuntu2404
      - "Using Ubuntu 24.04 LTS (Noble Numbat)"
      - "Using Ubuntu 22.04 LTS (Jammy Jellyfish)"
      
  NetworkInfo:
    Description: Information about the selected network profile
    Value: !Sub "Using ${NetworkProfile} network profile"
    
  StartupInfo:
    Description: Information on how to check status and logs
    Value: !Sub "To check Bitcoin sync status: ssh ubuntu@${CounterpartyInstance.PublicDnsName} '~/check-sync-status.sh'; To check Counterparty logs: ssh ubuntu@${CounterpartyInstance.PublicDnsName} 'docker logs counterparty-core'"